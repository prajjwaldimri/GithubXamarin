{"Name":"Android Support Design Library","Id":3113,"Alias":"xamandroidsupportdesign","Description":"\n# Design Android Support Library\n\nThe Design Support Library provides APIs to support adding material design components and patterns to your apps.\n\nThe Design Support Library adds support for various material design components and patterns for app developers to build upon, such as navigation drawers, floating action buttons (FAB), snackbars, and tabs.\n\n\n\n\n## Android Support Libraries\n\nThe Android Support Libraries are a set of code libraries that provide backward-compatible versions of Android framework APIs as well as features that are only available through the library APIs. Each Support Library is backward-compatible to a specific Android API level. This design means that your applications can use the libraries\u0027 features and still be compatible with devices running older versions of Android.\n\nIncluding the Support Libraries in your Android project is considered a best practice for application developers, depending on the range of platform versions your app is targeting and the APIs that it uses. Using the features the libraries provide can help you improve the look of your application, increase performance and broaden the reach of your application to more users. \n\n\n","Version":"24.2.1.0","Summary":"Provide backward-compatible versions of Android framework APIs.","QuickStart":"Design Support Library\n======================\n\nThe Android Design Support Library brings a number of important material design elements to older Android devices.  \n\n### Prerequisites\n\n**Themes**\n\nAny activity you use Design Support library views in must either use the theme `Theme.AppCompat` or inherit from `Theme.AppCompat` found in the AppCompat v7 Support library.\n\n**Target SDK Version**\n\nUsing this support library requires that your app have its Target Android Version (*targetSdkVersion*) set to Lollipop (5.0 - API Level 21) or higher, or you will have *aapt* related compile errors.  You can still set the Target Framework which your app is compiled against as low as Android 4.0.3 (API Level 15).\n\n\nSnackbar\n--------\nProviding lightweight, quick feedback about an operation is a perfect opportunity to use a snackbar.  Snackbars are shown on the bottom of the screen and contain text with an optional single action. They automatically time out after the given time length by animating off the screen. In addition, users can swipe them away before the timeout.\n\nBy including the ability to interact with the Snackbar through swiping it away or actions, these are considerably more powerful than toasts, another lightweight feedback mechanism.  However, you’ll find the API very similar:\n\n```csharp\nSnackbar\n  .Make (parentLayout, \"Text Here\", Snackbar.LengthLong)\n  .SetAction (Resource.String.snackbar_action, () =\u003e { })\n  .Show (); // Don’t forget to show!\n```\n\nYou’ll note the use of a `View` as the first parameter to `Make ()` - Snackbar will attempt to find an appropriate parent of the Snackbar’s view to ensure that it is anchored to the bottom.\n\n\n\n\nNavigation View\n----------------\nThe navigation drawer can be an important focal point for identity and navigation within your app and consistency in the design here can make a considerable difference in how easy your app is to navigate, particularly for first time users.  `NavigationView` makes this easier by providing the framework you need for the navigation drawer as well as the ability to inflate your navigation items through a menu resource.\n\nYou use `NavigationView` as `DrawerLayout`\u0027s drawer content view with a layout such as:\n\n```xml\n\u003candroid.support.v4.widget.DrawerLayout\n        xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:fitsSystemWindows=\"true\"\u003e\n\n    \u003c!-- your content layout --\u003e\n\n    \u003candroid.support.design.widget.NavigationView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"match_parent\"\n            android:layout_gravity=\"start\"\n            app:headerLayout=\"@layout/drawer_header\"\n            app:menu=\"@menu/drawer\"/\u003e\n\u003c/android.support.v4.widget.DrawerLayout\u003e\n```\n\nYou’ll note two attributes for NavigationView: app:headerLayout controls the (optional) layout used for the header. `app:menu` is the menu resource inflated for the navigation items (which can also be updated programmatically).  `NavigationView` takes care of the scrim protection of the status bar for you, ensuring that your `NavigationView` interacts with the status bar appropriately on API21+ devices.\n\nThe simplest drawer menus will be a collection of checkable menu items:\n\n```xml\n\u003cgroup android:checkableBehavior=\"single\"\u003e\n    \u003citem\n        android:id=\"@+id/navigation_item_1\"\n        android:checked=\"true\"\n        android:icon=\"@drawable/ic_android\"\n        android:title=\"@string/navigation_item_1\"/\u003e\n    \u003citem\n        android:id=\"@+id/navigation_item_2\"\n        android:icon=\"@drawable/ic_android\"\n        android:title=\"@string/navigation_item_2\"/\u003e\n\u003c/group\u003e\n```\n\nThe checked item will appear highlighted in the navigation drawer, ensuring the user knows which navigation item is currently selected.\n\nYou can also use subheaders in your menu to separate groups of items:\n\n```xml\n\u003citem\n    android:id=\"@+id/navigation_subheader\"\n    android:title=\"@string/navigation_subheader\"\u003e\n    \u003cmenu\u003e\n        \u003citem\n            android:id=\"@+id/navigation_sub_item_1\"\n            android:icon=\"@drawable/ic_android\"\n            android:title=\"@string/navigation_sub_item_1\"/\u003e\n        \u003citem\n            android:id=\"@+id/navigation_sub_item_2\"\n            android:icon=\"@drawable/ic_android\"\n            android:title=\"@string/navigation_sub_item_2\"/\u003e\n    \u003c/menu\u003e\n\u003c/item\u003e\n```\n\nYou’ll get callbacks on selected items by subscribing to the `NavigationItemSelected` event.  This provides you with the `MenuItem` that was clicked, allowing you to handle selection events, changed the checked status, load new content, programmatically close the drawer, or any other actions you may want.\n\n\n\n\nFloating Action Button\n----------------------\nA floating action button is a round button denoting a primary action on your interface.  The Design library’s `FloatingActionButton` gives you a single consistent implementation, by default colored using the `colorAccent` from your theme.\n\nIn addition to the normal size floating action button, it also supports the mini size (`fabSize=\"mini\"`) when visual continuity with other elements is critical.  As `FloatingActionButton` extends `ImageView`, you’ll use `android:src` or any of the methods such as `SetImageDrawable ()` to control the icon shown within the `FloatingActionButton`.\n\n\n\n\nFloating labels for editing text\n--------------------------------\n\nEven the humble `EditText` has room to improve in material design. While an `EditText` alone will hide the hint text after the first character is typed, you can now wrap it in a `TextInputLayout`, causing the hint text to become a floating label above the `EditText`, ensuring that users never lose context in what they are entering:\n\n```xml\n\u003candroid.support.design.widget.TextInputLayout\n\tandroid:layout_width=\"match_parent\"\n\tandroid:layout_height=\"wrap_content\"\u003e\n\t\n\t\u003cEditText\n\t\tandroid:id=\"@+id/editTextFirstName\"\n\t\tandroid:layout_width=\"fill_parent\"\n\t\tandroid:layout_height=\"wrap_content\"\n\t\tandroid:hint=\"First Name\" /\u003e\n\n\u003c/android.support.design.widget.TextInputLayout\u003e\n``` \n\nIn addition to showing hints, you can also display an error message below the `EditText` by calling `SetError ()`.\n\n\n\nTabs\n----\nSwitching between different views in your app via tabs is not a new concept to material design and they are equally at home as a top level navigation pattern or for organizing different groupings of content within your app (say, different genres of music).\n\nThe Design library’s `TabLayout` implements both fixed tabs, where the view’s width is divided equally between all of the tabs, as well as scrollable tabs, where the tabs are not a uniform size and can scroll horizontally. Tabs can be added programmatically:\n\n```csharp\nvar tabLayout = ...;\n\ntabLayout.AddTab (tabLayout.NewTab ().SetText (\"Tab 1\"));\n```\n\nHowever, if you are using a `ViewPager` for horizontal paging between tabs, you can create tabs directly from your `PagerAdapter`’s `PageTitle` and then connect the two together using `SetupWithViewPager ()`.  This ensures that tab selection events update the `ViewPager` and page changes update the selected tab.\n\n\n\n\nCoordinatorLayout, motion, and scrolling\n----------------------------------------\n\nDistinctive visuals are only one part of material design: motion is also an important part of making a great material designed app.  While there are a lot of parts of motion in material design including touch ripples and meaningful transitions, the Design library introduces `CoordinatorLayout`, a layout which provides an additional level of control over touch events between child views, something which many of the components in the Design library take advantage of.\n\n\n\n\nCoordinatorLayout and floating action buttons\n---------------------------------------------\n\nA great example of this is when you add a `FloatingActionButton` as a child of your `CoordinatorLayout` and then pass that `CoordinatorLayout` to your `Snackbar.Make ()` call - instead of the snackbar displaying over the floating action button, the `FloatingActionButton` takes advantage of additional callbacks provided by `CoordinatorLayout` to automatically move upward as the snackbar animates in and returns to its position when the snackbar animates out on Android 3.0 and higher devices - no extra code required.\n\n`CoordinatorLayout` also provides an `layout_anchor` attribute which, along with `layout_anchorGravity`, can be used to place floating views, such as the `FloatingActionButton`, relative to other views.\n\n\n\n\nCoordinatorLayout and the app bar\n---------------------------------\n\nThe other main use case for the `CoordinatorLayout` concerns the app bar (formerly action bar) and scrolling techniques.  You may already be using a `Toolbar` in your layout, allowing you to more easily customize the look and integration of that iconic part of an app with the rest of your layout.  The Design library takes this to the next level: using an `AppBarLayout` allows your `Toolbar` and other views (such as tabs provided by `TabLayout`) to react to scroll events in a sibling view marked with a `ScrollingViewBehavior`. Therefore you can create a layout such as:\n\n```xml\n\u003candroid.support.design.widget.CoordinatorLayout\n\txmlns:android=\"http://schemas.android.com/apk/res/android\"\n\txmlns:app=\"http://schemas.android.com/apk/res-auto\"\n\tandroid:layout_width=\"match_parent\"\n\tandroid:layout_height=\"match_parent\"\u003e\n\n\t\u003c! -- Your Scrollable View --\u003e\n\t\u003candroid.support.v7.widget.RecyclerView\n\t\tandroid:layout_width=\"match_parent\"\n\t\tandroid:layout_height=\"match_parent\"\n\t\tapp:layout_behavior=\"@string/appbar_scrolling_view_behavior\" /\u003e\n\n\t\t\u003candroid.support.design.widget.AppBarLayout\n\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\tandroid:layout_height=\"wrap_content\"\u003e\n\t\t\t\u003candroid.support.v7.widget.Toolbar\n\t\t\t\t...\n\t\t\t\tapp:layout_scrollFlags=\"scroll|enterAlways\"\u003e\n\n\t\t\t\t\u003candroid.support.design.widget.TabLayout\n\t\t\t\t\t...\n\t\t\t\t\tapp:layout_scrollFlags=\"scroll|enterAlways\" /\u003e\n\t\t\t\t\t\n\t\t\t\u003c/android.support.v7.widget.Toolbar\u003e\n\t\t\t\n\t\t\u003c/android.support.design.widget.AppBarLayout\u003e\n\t\t\n\u003c/android.support.design.widget.CoordinatorLayout\u003e\n```\n\nNow, as the user scrolls the `RecyclerView`, the `AppBarLayout` can respond to those events by using the children’s scroll flags to control how they enter (scroll on screen) and exit (scroll off screen). Flags include:\n\n - `scroll` this flag should be set for all views that want to scroll off the     \n - `screen` for views that do not use this flag, they’ll remain pinned to the top of the screen\n - `enterAlways` this flag ensures that any downward scroll will cause this view to become visible, enabling the *quick return* pattern\n - `enterAlwaysCollapsed` When your view has declared a minHeight and you use this flag, your View will only enter at its minimum height (i.e., *collapsed*), only re-expanding to its full height when the scrolling view has reached it’s top.\n - `exitUntilCollapsed` this flag causes the view to scroll off until it is *collapsed* (its minHeight) before exiting\n\nOne note: all views using the scroll flag must be declared before views that do not use the flag. This ensures that all views exit from the top, leaving the fixed elements behind.\n\n\n\n\nCollapsing Toolbars\n-------------------\n\nAdding a `Toolbar` directly to an `AppBarLayout` gives you access to the `enterAlwaysCollapsed` and `exitUntilCollapsed` scroll flags, but not the detailed control on how different elements react to collapsing. For that, you can use `CollapsingToolbarLayout`:\n\n```xml\n\u003candroid.support.design.widget.AppBarLayout\n\tandroid:layout_height=\"192dp\"\n\tandroid:layout_width=\"match_parent\"\u003e\n\t\n\t\u003candroid.support.design.widget.CollapsingToolbarLayout\n\t\tandroid:layout_width=\"match_parent\"\n\t\tandroid:layout_height=\"match_parent\"\n\t\tapp:layout_scrollFlags=\"scroll|exitUntilCollapsed\"\u003e\n\t\t\n\t\t\u003candroid.support.v7.widget.Toolbar\n\t\t\tandroid:layout_height=\"?attr/actionBarSize\"\n\t\t\tandroid:layout_width=\"match_parent\"\n\t\t\tapp:layout_collapseMode=\"pin\"/\u003e\n\t\t\t\n\t\u003c/android.support.design.widget.CollapsingToolbarLayout\u003e\n\t\n\u003c/android.support.design.widget.AppBarLayout\u003e\n```\n\nThis setup uses `CollapsingToolbarLayout`’s `app:layout_collapseMode=\"pin\"` to ensure that the `Toolbar` itself remains pinned to the top of the screen while the view collapses.  Even better, when you use `CollapsingToolbarLayout` and `Toolbar` together, the title will automatically appear larger when the layout is fully visible, then transition to its default size as it is collapsed. Note that in those cases, you should call `SetTitle ()` on the `CollapsingToolbarLayout`, rather than on the `Toolbar` itself.\n\nIn addition to pinning a view, you can use `app:layout_collapseMode=\"parallax\"` (and optionally `app:layout_collapseParallaxMultiplier=\"0.7\"` to set the parallax multiplier) to implement parallax scrolling (say of a sibling `ImageView` within the `CollapsingToolbarLayout`). This use case pairs nicely with the `app:contentScrim=\"?attr/colorPrimary\"` attribute for `CollapsingToolbarLayout`, adding a full bleed scrim when the view is collapsed.\n\n\n\n\nCoordinatorLayout and custom views\n----------------------------------\n\nOne thing that is important to note is that `CoordinatorLayout` doesn’t have any innate understanding of a `FloatingActionButton` or `AppBarLayout` work - it just provides an additional API in the form of a `Coordinator.Behavior`, which allows child views to better control touch events and gestures as well as declare dependencies between each other and receive callbacks via `OnDependentViewChanged ()`.\n","Hash":"552ab21324d1fba229f37a039b65f5bd","TargetPlatforms":["android"],"TrialHash":null}